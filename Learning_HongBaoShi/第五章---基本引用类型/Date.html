<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5.1</title>
    <script>
        // Date
        // Date 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）
        // 时间1970 年1 月1 日午夜（零时）至今所经过的毫秒数。
        let now = new Date() ;
        console.log (now) ;
        // parse 接收一个表示日期的字符串参数，尝试将这个字符串转换为
        // 表示为该日期的毫秒数例
        let someDate = new Date( Date.parse("May 23, 2019")) ;
        console.log (someDate) ;
        // 如果传给Date.parse()的字符串并不表示日期，则该方法会返回NaN。
        // 如果直接把表示日期的字符串传给Date 构造函数，
        // 那么Date 会在后台调用Date.parse()。
        let someDate2 = new Date("May 23, 2019") ;
        console.log (someDate2) ;
        console.log(someDate == someDate2);

        // Date.UTC()的参数是年、零起点月数（1 月是0，2 月是1，以此类推）、日(1~31）、时（0~23）、
        // 分、秒和毫秒。
        let y2k = new Date(Date.UTC(2023, 0)) ;
        console.log(y2k) ;
        let allFives = new Date(Date.UTC(2023, 2, 20, 22, 7, 30)) ;
        console.log(allFives) ;

        let y2k2 = new Date( 2023, 0) ;
        let allFives2 = new Date( 2023, 2, 20, 22, 7, 30 ) ;
        console.log ( y2k2 ) ;
        console.log ( allFives2 ) ;


        // ECMAScript还提供了Date.now()方法，表示方法执行时日期和时间的
        // 的毫秒数。
        function daSomething(){
            alert("Hello") ;
        }
        let start = Date.now() ;
        daSomething() ;
        let stop = Date.now() ;
        let result = stop - start ;
        console.log( result ) ;


        // RegExp-----筛选文本
        // 语法: let expression = /pattern/flags 
        let patttern1 = "/at/g" ;
        let patttern2 = "/[bc]at/i" ;
        let pattern3 = "/.at/gi" ;

        let expattern = new RegExp("[bc]at" , "i") ;
        console.log( expattern ) ;
        

        
        const re1 = "/cat/g" ;
        console.log( re1) ;


        let text = 'a cat go and a cat come';
        l4 = /a\s((cat)\sgo)/g;
        console.log(l4.exec(text));
        // (3) ["a cat go", "cat go", "cat", index: 0, input: "a cat go and a cat come", groups: undefined]


        // 原始包装类型:Boolean 、Number & String
        /** 原本初始值在逻辑上不应该有方法
         *  实际上，后台进行的操作：
         * 创建一个String类型的实例
         * 调用实例上的特定方法
         * 销毁实例
        */
        let s1 = "some text" ;
        let s2 = s1.substring(2) ;
        console.log(s1, s2) ;
        /**
         * let s1 = new String("some text") ;
         * let s2 = s1.substring(2) ;
         * s1 = null ;
        */
        s1.color = 1 ;
        console.log(s1.color) ;
        console.log( String ) ;

        let obj = new Object("some text") ;
        console.log( typeof obj ) ;
        console.log ( obj instanceof String ) ;

        /**
         * Boolean
        */
       let booleanobject = new Boolean(false) ;
       let resultbol = booleanobject && true ;
       console.log(resultbol) ;

        /**
         * Number
        */

        let numberObject = new Number(10) ;
        console.log( numberObject instanceof Number) ;
        console.log ( typeof numberObject) ;
        let number = 10 ;
        console.log ( number instanceof Number) ;
        console.log ( typeof number) ;

        console.log (Math.E) ;


        /**
         * String
        */
        let message = "abcde";
        console.log(message.charAt(2)); // "c"

        let stringValue = "hello ";
        let resultStr = stringValue.concat("world");
        console.log(resultStr); // "hello world"
        console.log(stringValue); // "hello"

        let stringValue2 = "hello world";
        console.log(stringValue2.indexOf("o")); // 4
        console.log(stringValue2.lastIndexOf("o")); // 7

        let stringValue3 = " hello world ";
        let trimmedStringValue = stringValue.trim();
        console.log(stringValue3); // " hello world "
        console.log(trimmedStringValue); // "hello world"

        /**
         * Global
         * ECMA-262 规定Global对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法。事实上，不存在全局变量或全局函数这种东西。
         * 在全局作用域中定义的变量和函数都会变成Global
         * 对象的属性 。
         * Global 对象有很多属性，其中一些前面已经提到过了。
         * 像undefined、NaN 和Infinity 等特殊值都是Global 对象的属性。
         * 此外，所有原生引用类型构造函数，比如Object 和Function，也都是Global 对象的属性。
        */
       let global = function (){
        return this ;
       }() ;
       
       console.log( global ) ; 

       let uri = "http://www.wrox.com/illegal value.js#start";
        // "http://www.wrox.com/illegal%20value.js#start"
       console.log(encodeURI(uri));
        // "http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start"
       console.log(encodeURIComponent(uri));

       let msg = "hello world";
       eval("console.log(msg)"); // "hello world"

       /**
        * 虽然ECMA-262 没有规定直接访问Global 对象的方式，
        * 但浏览器将window 对象实现为Global对象的代理。因此，
        * 所有全局作用域中声明的变量和函数都变成了window 的属性
       */

       /**
        * Math
       */
       let values = [1, 2, 3, 4, 5, 6, 7, 8];
       let max = Math.max(...values);
       console.log(max) ;

       总结
/**JavaScript 中的对象称为引用值，几种内置的引用类型可用于创建特定类型的对象。

引用值与传统面向对象编程语言中的类相似，但实现不同。
Date 类型提供关于日期和时间的信息，包括当前日期、时间及相关计算。
RegExp 类型是ECMAScript 支持正则表达式的接口，提供了大多数基础的和部分高级的正则表 达式功能。
JavaScript 比较独特的一点是，函数实际上是Function 类型的实例，也就是说函数也是对象。因为函数也是对象，所以函数也有方法，可以用于增强其能力。
由于原始值包装类型的存在，JavaScript 中的原始值可以被当成对象来使用。有3 种原始值包装类型：Boolean、Number 和String。它们都具备如下特点。

每种包装类型都映射到同名的原始类型。
以读模式访问原始值时，后台会实例化一个原始值包装类型的对象，借助这个对象可以操作相 应的数据。
涉及原始值的语句执行完毕后，包装对象就会被销毁。
当代码开始执行时，全局上下文中会存在两个内置对象：Global 和Math。其中，Global 对象在大多数ECMAScript 实现中无法直接访问。不过，浏览器将其实现为window 对象。所有全局变量和函数都是Global 对象的属性。Math 对象包含辅助完成复杂计算的属性和方法。*/


    </script>
</head>
<body>
    
</body>
</html>